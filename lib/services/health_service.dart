import 'package:health/health.dart';
import '../models/workout.dart';
import 'dart:math';

class HealthService {
  final Health _health = Health();

  Future<bool> requestAuthorization() async {
    final types = [
      HealthDataType.STEPS,
      HealthDataType.DISTANCE_WALKING_RUNNING,
      HealthDataType.ACTIVE_ENERGY_BURNED,
      HealthDataType.EXERCISE_TIME,
      HealthDataType.SLEEP_ASLEEP,
      HealthDataType.SLEEP_IN_BED,
      HealthDataType.SLEEP_AWAKE,
      HealthDataType.SLEEP_LIGHT,
      HealthDataType.SLEEP_DEEP,
      HealthDataType.SLEEP_REM,
      HealthDataType.HEART_RATE,
      HealthDataType.BLOOD_OXYGEN,
      HealthDataType.BODY_TEMPERATURE,
      HealthDataType.WORKOUT,
    ];
    return await _health.requestAuthorization(types);
  }

  Future<int> fetchTodaySteps() async {
    final now = DateTime.now();
    final startOfDay = DateTime(now.year, now.month, now.day);
    final data = await _health.getHealthDataFromTypes(
      types: [HealthDataType.STEPS],
      startTime: startOfDay,
      endTime: now,
    );
    int total = 0;
    for (final d in data) {
      if (d.value is NumericHealthValue) {
        total += (d.value as NumericHealthValue).numericValue.round();
      }
    }
    return total;
  }

  Future<List<Workout>> fetchTodayWorkouts() async {
    final now = DateTime.now();
    final start = DateTime(now.year, now.month, now.day);
    final workouts = await _health.getHealthDataFromTypes(
      types: [HealthDataType.WORKOUT],
      startTime: start,
      endTime: now,
    );
    final calories = await _health.getHealthDataFromTypes(
      types: [HealthDataType.ACTIVE_ENERGY_BURNED],
      startTime: start,
      endTime: now,
    );
    List<Workout> result = [];
    for (final w in workouts) {
      if (w.type == HealthDataType.WORKOUT) {
        double kcal = 0;
        for (final c in calories) {
          if (c.dateFrom.isBefore(w.dateTo) && c.dateTo.isAfter(w.dateFrom)) {
            if (c.value is NumericHealthValue) {
              kcal += (c.value as NumericHealthValue).numericValue;
            }
          }
        }
        final value = w.value;
        String type = 'UNKNOWN';
        if (value is WorkoutHealthValue) {
          type = value.workoutActivityType
              .toString()
              .replaceAll('HealthWorkoutActivityType.', '')
              .toUpperCase();
        }
        result.add(Workout(
          exerciseType: type,
          start: w.dateFrom,
          end: w.dateTo,
          calories: kcal,
        ));
      }
    }
    return result;
  }

  Future<Map<String, int>> fetchSleepData() async {
    final now = DateTime.now();
    final start = DateTime(now.year, now.month, now.day);
    final data = await _health.getHealthDataFromTypes(
      types: [
        HealthDataType.SLEEP_IN_BED,
        HealthDataType.SLEEP_AWAKE,
        HealthDataType.SLEEP_LIGHT,
        HealthDataType.SLEEP_DEEP,
        HealthDataType.SLEEP_REM,
      ],
      startTime: start,
      endTime: now,
    );
    final Map<String, int> result = {
      'inBed': 0,
      'awake': 0,
      'asleepCore': 0,
      'asleepDeep': 0,
      'asleepREM': 0,
    };
    for (final d in data) {
      final duration = d.dateTo.difference(d.dateFrom).inMinutes;
      switch (d.type) {
        case HealthDataType.SLEEP_IN_BED:
          result['inBed'] = result['inBed']! + duration;
          break;
        case HealthDataType.SLEEP_AWAKE:
          result['awake'] = result['awake']! + duration;
          break;
        case HealthDataType.SLEEP_LIGHT:
          result['asleepCore'] = result['asleepCore']! + duration;
          break;
        case HealthDataType.SLEEP_DEEP:
          result['asleepDeep'] = result['asleepDeep']! + duration;
          break;
        case HealthDataType.SLEEP_REM:
          result['asleepREM'] = result['asleepREM']! + duration;
          break;
        default:
          break;
      }
    }
    return result;
  }

  Future<Map<String, dynamic>> fetchVitalSigns() async {
    final now = DateTime.now();
    final start = DateTime(now.year, now.month, now.day);
    final result = {
      'heartRate': 1,
      'oxygenSaturation': 1,
      'bodyTemperature': 1.0,
    };
    final heart = await _health.getHealthDataFromTypes(
      types: [HealthDataType.HEART_RATE],
      startTime: start,
      endTime: now,
    );
    if (heart.isNotEmpty && heart.first.value is NumericHealthValue) {
      result['heartRate'] =
          (heart.first.value as NumericHealthValue).numericValue.round();
    }
    final oxygen = await _health.getHealthDataFromTypes(
      types: [HealthDataType.BLOOD_OXYGEN],
      startTime: start,
      endTime: now,
    );
    if (oxygen.isNotEmpty && oxygen.first.value is NumericHealthValue) {
      result['oxygenSaturation'] =
          (oxygen.first.value as NumericHealthValue).numericValue.round();
    }
    final temp = await _health.getHealthDataFromTypes(
      types: [HealthDataType.BODY_TEMPERATURE],
      startTime: start,
      endTime: now,
    );
    if (temp.isNotEmpty && temp.first.value is NumericHealthValue) {
      result['bodyTemperature'] =
          (temp.first.value as NumericHealthValue).numericValue.toDouble();
    }
    return result;
  }

  Future<Map<String, dynamic>> getTodayHealthData() async {
    final stepCount = await fetchTodaySteps();
    final workouts = await fetchTodayWorkouts();
    final vital = await fetchVitalSigns();
    final sleep = await fetchSleepData();

    final exerciseList = workouts.map((w) => w.toJson()).toList();
    final totalCalories =
        workouts.fold(0.0, (sum, w) => sum + (w.calories ?? 0.0));
    final exerciseTime = max(1, workouts.length * 10); // ÏµúÏÜå 1Î∂Ñ
    final distanceWalkingRunning = 1.0; // Í∏∞Î≥∏Í∞í (Ï∂îÌõÑ Ï∏°Ï†ï Í∞ÄÎä•)

    return {
      'stepCount': max(1, stepCount),
      'exercise': exerciseList,
      'vital': vital,
      'sleep': sleep,
      'activity': {
        'stepCount': max(1, stepCount),
        'activeEnergyBurned': max(1.0, totalCalories),
        'appleExerciseTime': exerciseTime,
        'distanceWalkingRunning': distanceWalkingRunning,
      },
    };
  }
}
/* ÏùºÎã® Í∞ÄÎ†§Îë†
  Future<Map<String, dynamic>> getTodayHealthData() async {
    final stepCount = await fetchTodaySteps();
    final workouts = await fetchTodayWorkouts();
    final vital = await fetchVitalSigns();
    final sleep = await fetchSleepData();

    return {
      'stepCount': stepCount,
      'exercise': workouts.map((w) => w.toJson()).toList(),
      'vital': vital,
      'sleep': sleep,
    };
  }
}
*/


/*
import 'package:health/health.dart';
import '../models/workout.dart';

class HealthService {
  final Health _health = Health();

  Future<bool> requestAuthorization() async {
    final types = [
      // ÌôúÎèô
      HealthDataType.STEPS, // Í±∏Ïùå Ïàò
      HealthDataType.DISTANCE_WALKING_RUNNING, //Í±∑Í±∞ÎÇò Îã¨Î†§ÏÑú Ïù¥ÎèôÌïú Í±∞Î¶¨
      HealthDataType.ACTIVE_ENERGY_BURNED, // ÏÜåÎ™®Ìïú ÌôúÏÑ± ÏóêÎÑàÏßÄ (kcal)
      HealthDataType.EXERCISE_TIME, // Ïö¥Îèô ÏãúÍ∞Ñ(Î∂Ñ)
      // HealthDataType.MOVE_TIME, // Ï†ÑÏã† ÏõÄÏßÅÏûÑ ÏÜåÏöî ÏãúÍ∞Ñ(Î∂Ñ)

      // ÏàòÎ©¥
      HealthDataType.SLEEP_ASLEEP,
      HealthDataType.SLEEP_IN_BED,
      HealthDataType.SLEEP_AWAKE,
      HealthDataType.SLEEP_LIGHT,
      HealthDataType.SLEEP_DEEP,
      HealthDataType.SLEEP_REM,

      // ÌôúÎ†•ÏßïÌõÑ
      HealthDataType.HEART_RATE,
      HealthDataType.BLOOD_OXYGEN, // ÏÇ∞ÏÜå Ìè¨ÌôîÎèÑ
      HealthDataType.BODY_TEMPERATURE,

      // Ïö¥Îèô Ïú†Ìòï
      HealthDataType.WORKOUT,
    ];

    return await _health.requestAuthorization(types);
  }

  String fallbackWorkoutType(HealthDataPoint point) {
    final unit = point.unit?.toString().toLowerCase() ?? '';
    final source = point.sourceName?.toLowerCase() ?? '';

    if (source.contains('run') || unit.contains('mile')) return 'RUNNING';
    if (source.contains('swim')) return 'SWIMMING';
    if (source.contains('walk')) return 'WALKING';
    if (source.contains('cycle')) return 'CYCLING';

    return 'UNKNOWN';
  }

  String extractWorkoutType(HealthDataPoint point) {
    final value = point.value;
    if (value is WorkoutHealthValue) {
      final raw = value.workoutActivityType.toString();
      print('üîç raw workoutActivityType: $raw');

      final cleaned =
          raw.toUpperCase().replaceAll('HEALTHWORKOUTACTIVITYTYPE.', '');

      print('‚úÖ cleaned type: $cleaned');
      return cleaned;
    }
    return fallbackWorkoutType(point);
  }

  Future<List<Workout>> fetchTodayWorkouts() async {
    print('üöÄ fetchTodayWorkouts() ÏãúÏûëÎê®');

    final now = DateTime.now();
    final startOfDay = DateTime(now.year, now.month, now.day);

    final workoutData = await _health.getHealthDataFromTypes(
      types: [HealthDataType.WORKOUT],
      startTime: startOfDay,
      endTime: now,
    );

    final calorieData = await _health.getHealthDataFromTypes(
      types: [HealthDataType.ACTIVE_ENERGY_BURNED],
      startTime: startOfDay,
      endTime: now,
    );

    print('üìä Ïö¥Îèô Îç∞Ïù¥ÌÑ∞ Ïàò: ${workoutData.length}');
    for (final w in workoutData) {
      print(
          'üëü Workout:\n  - value: ${w.value}\n  - unit: ${w.unit}\n  - source: ${w.sourceName}\n  - start: ${w.dateFrom}\n  - end: ${w.dateTo}\n  - metadata: ${w.metadata}');
    }

    print('üìä ÏπºÎ°úÎ¶¨ Îç∞Ïù¥ÌÑ∞ Ïàò: ${calorieData.length}');
    for (final c in calorieData) {
      print(
          'üî• Calorie:\n  - value: ${c.value}\n  - unit: ${c.unit}\n  - start: ${c.dateFrom}\n  - end: ${c.dateTo}\n  - type: ${c.type}');
    }

    final workouts = <Workout>[];

    for (final w in workoutData) {
      if (w.type == HealthDataType.WORKOUT) {
        final matchedCalories = calorieData.where((c) =>
            c.dateFrom.isBefore(w.dateTo) &&
            c.dateTo.isAfter(w.dateFrom) &&
            (c.value is num || c.value is NumericHealthValue));

        print('‚öñÔ∏è ${matchedCalories.length}Í∞úÏùò ÏπºÎ°úÎ¶¨ Îç∞Ïù¥ÌÑ∞Í∞Ä Ïö¥Îèô ÏãúÍ∞ÑÍ≥º Í≤πÏπ©ÎãàÎã§.');

        double calories = 0;
        for (final c in matchedCalories) {
          if (c.value is NumericHealthValue) {
            calories += (c.value as NumericHealthValue).numericValue;
          } else if (c.value is num) {
            calories += (c.value as num).toDouble();
          }
        }

        final workoutType = extractWorkoutType(w);

        print(
            'üÜï Workout Í∞ùÏ≤¥ ÏÉùÏÑ±\n  - type: $workoutType\n  - calories: $calories');

        workouts.add(Workout(
          exerciseType: workoutType,
          start: w.dateFrom,
          end: w.dateTo,
          calories: calories > 0 ? calories : -1,
        ));
      }
    }

    return workouts;
  }

  Future<int> fetchTodaySteps() async {
    final now = DateTime.now();
    final startOfDay = DateTime(now.year, now.month, now.day);

    final stepData = await _health.getHealthDataFromTypes(
      types: [HealthDataType.STEPS],
      startTime: startOfDay,
      endTime: now,
    );

    int totalSteps = 0;

    for (final d in stepData) {
      if (d.type == HealthDataType.STEPS && d.value is NumericHealthValue) {
        final numeric = (d.value as NumericHealthValue).numericValue;
        print('‚úÖ NumericHealthValueÎ°úÎ∂ÄÌÑ∞ Ï∂îÏ∂úÎêú Í∞í: $numeric');
        totalSteps += numeric.round();
      } else {
        print('üö´ Í±¥ÎÑàÎúÄ - valueType: ${d.value.runtimeType}');
      }
    }

    print('‚úÖ ÏµúÏ¢Ö Í≥ÑÏÇ∞Îêú totalSteps: $totalSteps');

    return totalSteps;
  }
}
*/